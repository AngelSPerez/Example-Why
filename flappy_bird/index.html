<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-capable" content="yes">
	<link rel="manifest" href="manifest.json">

	<title>Flappy Bird Game | Online Game</title>

	<script src="scripts.js"></script>

	<style>
    /* Eliminar margen, ocultar desbordamiento y establecer fondo */
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden; /* Prevenir barras de scroll */
        background-color: #000000 !important; /* Fondo negro para el "letterboxing" */
    }
	canvas {
		display: block;
		position: absolute;
		margin: auto; /* Centrar el canvas */
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
        
        /* * LA CORRECCIÓN: 
         * Desactiva todas las acciones táctiles por defecto del navegador 
         * (como doble toque para zoom, pellizcar para zoom, etc.)
         * Esto elimina el retraso de 300ms en móviles.
         */
        touch-action: none;
	}
	</style>
</head>
<body>
<script>
var 

canvas,
ctx,
width,
height,
scale = 1, // Factor de escala para redimensionar

fgpos=0,
frames=0,
score=0,
best=0,

currentstate,
states={
    Splash:0,Game:1,Score:2
},

bird={
    x:60,
	 y:100,
	 frame:0,
	 velocity:0,
	 animation:[0,1,2,1],
	 rotation:0,
	 gravity:0.25,
	 _jump:4.6,
	 radius: 5,
	 
	 jump:function(){
	    this.velocity=-this._jump;
	 },
	 
	 update:function(){
	  var n=(currentstate===states.Splash)?10:5;
	  this.frame += (frames%n)===0 ? 1:0;
	  
      this.frame= this.frame %this.animation.length;
     
	    
	  if(currentstate===states.Splash){
	  this.y=height-280+5*Math.cos(frames/10);
	  this.rotation=0;
	  }
	  else {
	  this.velocity+=this.gravity;
	 
	  this.y+=this.velocity;
	 if(this.y >=height-s_fg.height-10){
	     this.y=height-s_fg.height-10;
		 if(currentstate===states.Game)
		      currentstate=states.Score;
		 this.velocity=this._jump;
		 }	 
         
         if(this.velocity>=this._jump){
		    this.frame=1;
			this.rotation=Math.min(Math.PI/6,this.rotation+0.3);
			
		 }else{
		 this.rotation=-0.3;
		 }		 
		 
	  }
	 },
	 
	 draw:function(ctx){
	 ctx.save();
	 ctx.translate(this.x,this.y);
	 ctx.rotate(this.rotation);
	 var n=this.animation[this.frame];
	 s_bird[n].draw(ctx, -s_bird[n].width/2 , -s_bird[n].height/2);
	 
	
	 
	 ctx.restore();
	 
	 }
	 
},

pipes={

       _pipes:[],
	   reset:function(){
	      this._pipes=[];
	   },
      update:function(){
	     if(frames%100===0){
		  var _y=height-(s_pipeSouth.height+s_fg.height+180+200*Math.random());
		  this._pipes.push({
             x:500,
             y:_y,
             width:s_pipeSouth.width,
             height:s_pipeSouth.height			 
		  });
		  }
		  
		  
		  
		  for(var i=0,len=this._pipes.length;i<len;i++)
		 {
		  var p=this._pipes[i];
		  
            if(i===0){
			score+=(p.x===bird.x )?1:0 ;
			var cx=Math.min(Math.max(bird.x,p.x),p.x+p.width);
			var cy1=Math.min(Math.max(bird.y,p.y),p.y+p.height);
			var cy2=Math.min(Math.max(bird.y,p.y+p.height+80),p.y+2*p.height+80);
			
			var dx=(bird.x)-cx;
			var dy1=bird.y-cy1;
			var dy2=bird.y-cy2;
			
			var d1=dx*dx + dy1+dy1;
			var d2=dx*dx + dy2*dy2;
			
			var r=bird.radius+bird.radius;
			if(r>d1 || r>d2){
			currentstate=states.Score;
			}
			}
            
		
		  p.x-=2;
		  if(p.x<-50)
		  {
		  this._pipes.splice(i,1);
		  i--;
		  len--;
		  }
		  
		 }
	  },
	  
	  
	  draw:function(ctx){
	  for(var i=0,len=this._pipes.length;i<len;i++){
	  var p=this._pipes[i];
	  s_pipeSouth.draw(ctx,p.x,p.y);
	  s_pipeNorth.draw(ctx,p.x,p.y+95+p.height);
	  		 

	  }
	  }
};

function onpress(evt){
    var mx, my;

    // Obtener la posición del canvas en la pantalla
    var rect = canvas.getBoundingClientRect();

    if (evt.touches) { // Evento táctil
        // Ya no se necesita evt.preventDefault() gracias al CSS 'touch-action: none'
        mx = evt.touches[0].clientX - rect.left;
        my = evt.touches[0].clientY - rect.top;
    } else { // Evento de mouse
        // Ya no se necesita evt.preventDefault()
        mx = evt.clientX - rect.left;
        my = evt.clientY - rect.top;
    }

    // Re-escalar las coordenadas al tamaño lógico del juego (320x480)
    mx /= scale;
    my /= scale;

    switch(currentstate){
    case states.Splash:
         currentstate=states.Game;
         bird.jump();
         break;
    case states.Game:
         bird.jump();
         break;
    case states.Score:
          // --- INICIO DE LA MODIFICACIÓN ---
          // Ahora cualquier toque reinicia el juego.
          // Se eliminó la comprobación de las coordenadas del botón 'okbtn'.
          pipes.reset();
          score=0;
          currentstate=states.Splash;
          // --- FIN DE LA MODIFICACIÓN ---
         break;
    }
}


function main(){
     currentstate=states.Splash;
     canvas=document.createElement("canvas");
	 
     // Dimensiones base del juego (lógicas)
	 width=320;
	 height=480;

	 // Establecer el tamaño de renderizado del canvas
	 canvas.width=width;
	 canvas.height=height;
	 
     // --- INICIO DE LA MODIFICACIÓN ---
     // Calcular los factores de escala para ancho y alto
     var scaleX = window.innerWidth / width;
     var scaleY = window.innerHeight / height;
     
     // Usar el factor de escala MÁS PEQUEÑO para asegurar que todo el juego quepa
     // (Esto mantiene la relación de aspecto y evita que se corte la imagen)
     scale = Math.min(scaleX, scaleY);
     // --- FIN DE LA MODIFICACIÓN ---

     // Establecer el tamaño de *estilo* del canvas a sus dimensiones base
     // El transform se encargará del escalado visual
     canvas.style.width = width + "px";
     canvas.style.height = height + "px";
     
     // Aplicar el transform para escalar
     // El CSS (position: absolute, margin: auto) se encarga de centrarlo
     canvas.style.transform = "scale(" + scale + ")";

	 var evt="touchstart";
	 if (!('ontouchstart' in window)) { // Comprobar soporte táctil
	    evt="mousedown";
     }
	 
     // Añadir listener
     // Ya no se necesita { passive: false } porque no llamamos a preventDefault()
	 document.addEventListener(evt, onpress); 

	 ctx=canvas.getContext("2d");
	 document.body.appendChild(canvas);
	
	 var img=new Image();
	 
	 img.onload=function(){
	 initSprites(this );
	 ctx.fillStyle=s_bg.color;
	 okbtn={
	     x:(width-s_buttons.Ok.width)/2,
		 y:height-200,
		 width:s_buttons.Ok.width,
		 height:s_buttons.Ok.height
	 }
	 run();
	 } 
	 
	 img.src="sheet.png";
	 
	 
	 
}

function run()
{
     var loop=function(){
            update();
			render();
			 window.requestAnimationFrame(loop,canvas);
        }
		window.requestAnimationFrame(loop,canvas);
}

function update(){
       frames++;
       if(currentstate!== states.Score){
	   fgpos=(fgpos-2)%14;
       
	   }
	   else
	   { best=Math.max(best,score);}
	   if(currentstate===states.Game)
	   {pipes.update();}
	   
       bird.update();
	   }

function render(){

	  ctx.fillRect(0,0,width,height);
      s_bg.draw(ctx,0,height-s_bg.height);  
      s_bg.draw(ctx,s_bg.width,height-s_bg.height);  

      bird.draw(ctx);	  
	  pipes.draw(ctx);

	  s_fg.draw(ctx,fgpos,height-s_fg.height);
	  s_fg.draw(ctx,fgpos+s_fg.width,height-s_fg.height); 
      
	  var width2=width/2;
	  if(currentstate===states.Splash){
	  s_splash.draw(ctx,width2-s_splash.width/2,height-300);
	  s_text.GetReady.draw(ctx,width2-s_text.GetReady.width/2,height-400);
	  }
	  
	  if(currentstate===states.Score){
	  s_text.GameOver.draw(ctx,width2-s_text.GameOver.width/2,height-400);
	s_score.draw(ctx,width2-s_score.width/2,height-340);
	
	  // --- INICIO DE LA MODIFICACIÓN ---
	  // s_buttons.Ok.draw(ctx,okbtn.x,okbtn.Y); // Botón OK ya no es necesario
	  // --- FIN DE LA MODIFICACIÓN ---
	  
	  s_numberS.draw(ctx,width2-47,height-304,score,null,10);
	  s_numberS.draw(ctx,width2-47,height-262,best,null,10);
	  }else{
	  s_numberB.draw(ctx,null ,20,score,width2,null);
	  }
}

main();

</script>

<script>
	if ('serviceWorker' in navigator) {
	  window.addEventListener('load', () => {
		navigator.serviceWorker.register('sw.js')
		  .then(reg => console.log('✅ Service Worker registrado con éxito:', reg.scope))
		  .catch(err => console.log('❌ Error al registrar el Service Worker:', err));
	  });
	}
</script>


</body>
</html>
